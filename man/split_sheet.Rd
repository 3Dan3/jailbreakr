% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/split_sheet.R
\name{split_sheet}
\alias{split_sheet}
\alias{split_sheet_apply}
\alias{split_sheet_find}
\title{Classify and split sheet}
\usage{
split_sheet(sheet)

split_sheet_find(sheet)

split_sheet_apply(sheet, limits)
}
\arguments{
\item{sheet}{A linen \code{worksheet} object, possibly from an
Excel or googlesheets spreadsheet.}

\item{limits}{A list of \code{cellranger::cell_limits} object, as
returned by \code{split_sheet_find}.}

\item{as}{Character, indicating what to return - \code{"limits"}:
a list of limits (the default), \code{"groups"} a matrix of the
same dimensions as the worksheet indicating what group each cell
is in, or \code{"both"}: a list with elements \code{"limits"}
and \code{"groups"}.}
}
\value{
For \code{split_sheet} and \code{split_sheet_apply}, a
  list of worksheet views; each view corresponds to one region of
  the sheet and the order within the list is currently arbitrary
  (but may be ordered predictably in a future version).  For
  \code{split_sheet_find}, a list of
  \code{cellranger::cell_limits} objects, each corresponding to a
  region of the sheet that represents a separate rectangular
  region (again, order is arbitrary for now)
}
\description{
Classify a table into sub-regions.  We're looking for a (possibly
ragged) block of cells surrounded by a set of blank cells or the
edge of the sheet.  This does not detect regions that are multiple
square regions offset from each other, but that could possibly be
done afterwards.
}
\details{
This function works by applying the "flood fill" algorithm to
non-blank cells in the worksheet and then squaring off the result.

The \code{split_sheet_find} function does the actual
classification, and \code{split_sheet_apply} applies
\code{worksheet_view} to these to produce something that can be
used (approximately) as if it was a separate sheet.
}

